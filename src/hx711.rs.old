/// The hx711 is a load cell amplifier
/// This implements the hx711 using `embedded-hal` traits
///
///
use core::convert::Infallible;
use core::mem::transmute;

use embedded_hal::blocking::delay::DelayUs;

use embedded_hal::digital::v2::{InputPin, OutputPin};

use crate::LoadCell;

#[repr(u8)]
#[derive(Clone, Copy)]
pub enum GainMode {
    A128 = 1, // extra pulses
    B32 = 2,
    A64 = 3,
}

pub const HX711_MINIMUM: i32 = -(2i32.saturating_pow(24 - 1));
pub const HX711_MAXIMUM: i32 = 2i32.saturating_pow(24 - 1) - 1;
const HX711_DELAY_TIME_US: u32 = 1;

// pub enum UseMode {
//     INTERRUPT,
//     SYNC,
// }

pub struct HX711<SckPin, DTPin, Delay>
where
    SckPin: OutputPin,
    DTPin: InputPin,
    Delay: DelayUs<u32>,
{
    sck_pin: SckPin,
    dt_pin: DTPin,
    delay: Delay,
    last_reading: i32,
    gain_mode: GainMode,
    offset: i32, // tare
    scale: Option<f32>, // calibration value,
                 // use_mode: UseMode,
}

impl<SckPin, DTPin, Delay> HX711<SckPin, DTPin, Delay>
where
    SckPin: OutputPin<Error = Infallible>,
    DTPin: InputPin<Error = Infallible>,
    Delay: DelayUs<u32>,
{
    pub fn new(mut sck_pin: SckPin, mut dt_pin: DTPin, delay: Delay) -> Self {
        sck_pin.set_low().unwrap();
        // dt_pin.listen(Event::FallingEdge);
        Self {
            sck_pin,
            dt_pin,
            delay,
            last_reading: 0,
            gain_mode: GainMode::A64,
            offset: 0,
            scale: Some(0.0),
            // use_mode: UseMode::INTERRUPT,
        }
    }
    fn is_ready(&self) -> bool {
        self.dt_pin.is_low().unwrap()
    }

    fn read_hx711_bit(&mut self, hx711_delay_time_us: u32) -> bool {
        self.sck_pin.set_high().unwrap();
        self.delay.delay_us(hx711_delay_time_us);

        // read dt pin
        let mut pin_state = true;
        if self.dt_pin.is_low().unwrap() {
            pin_state = false;
        }

        self.sck_pin.set_low().unwrap();
        self.delay.delay_us(hx711_delay_time_us);

        // return
        pin_state
    }

    pub fn toggle_sck_bit(&mut self, hx711_delay_time_us: u32) {
        self.sck_pin.set_high().unwrap();
        self.delay.delay_us(hx711_delay_time_us);
        self.sck_pin.set_low().unwrap();
        self.delay.delay_us(hx711_delay_time_us);
    }

    pub fn set_gain_mode(&mut self, gain_mode: GainMode) {
        self.gain_mode = gain_mode;
    }

    pub fn get_gain_mode(&self) -> GainMode {
        self.gain_mode
    }
    //    pub fn activate_interrupt(&mut self) {
    //         // self.sck_pin.set_low().unwrap();
    //         self.use_mode = UseMode::INTERRUPT;
    //         // if let UseMode::INTERRUPT = self.use_mode {
    //         // } else {
    //         //     panic!("Hx711 Peripheral not in interrupt mode.")
    //         // }
    //         // self.dt_pin.
    //         if self.dt_pin.is_listening() {
    //             self.dt_pin.unlisten();
    //         }
    //         self.dt_pin.listen(Event::FallingEdge);
    //     }

    // /// listen for interrupt events
    // pub fn deactivate_interrupt(&mut self) {
    //     // self.sck_pin.set_low().unwrap();
    //     if let UseMode::INTERRUPT = self.use_mode {
    //     } else {
    //         panic!("Hx711 Peripheral not in interrupt mode.")
    //     }
    //     if self.dt_pin.is_listening() {
    //         self.dt_pin.unlisten();
    //     }
    //     self.use_mode = UseMode::SYNC;
    //     // self.dt_pin.listen(Event::FallingEdge);
    // }
}

impl<SckPin, DTPin, Delay> LoadCell for HX711<SckPin, DTPin, Delay>
where
    SckPin: OutputPin<Error = Infallible>,
    DTPin: InputPin<Error = Infallible>,
    Delay: DelayUs<u32>,
{
    type Offset = u32;
    type Scale = Option<f32>;

    fn read(&mut self) -> i32 {
        if !self.is_ready() {
            // if let UseMode::INTERRUPT = self.use_mode {
            //     self.dt_pin.clear_interrupt();
            // }

            return HX711_MINIMUM;
        }

        //data ready
        let mut current_bit: u32;
        let mut value: u32 = 0;
        // read in data bits
        for _ in 0..24 {
            current_bit = self.read_hx711_bit(HX711_DELAY_TIME_US) as u32;
            // bits arrive MSB first
            value = (value << 1) | current_bit;
        }
        // send gain mode for next reading
        let current_gain_mode = self.gain_mode as u8;
        for _ in 0..current_gain_mode {
            self.toggle_sck_bit(HX711_DELAY_TIME_US);
        }

        /* msb padding, if the 24 bit number is negative.
         */
        if value & 0b10000000_00000000_00000000 >= 1 {
            // negative, fill with 1s
            value |= 0b11111111_00000000_00000000_00000000_u32;
        }
        let mut signed = unsafe { transmute::<u32, i32>(value) };
        // saturation
        if signed < HX711_MINIMUM {
            signed = HX711_MINIMUM;
        } else if signed > HX711_MAXIMUM {
            signed = HX711_MAXIMUM;
        }
        self.last_reading = signed;

        // if let UseMode::INTERRUPT = self.use_mode {
        //     self.dt_pin.clear_interrupt();
        // }
        // return
        signed
    }

    fn get_offset(&self) -> Self::Offset {
        self.offset as Self::Offset
    }

    fn get_scale(&self) -> Self::Scale {
        self.scale as Self::Scale
    }

    fn read_scaled(&mut self) -> Option<f32> {
        let raw = self.read();
        self.scale.map(|x| raw as f32 * x)
        // match self.scale {
        //     Some(x) => Some(raw as f32 * x),
        //     _ => None,
        // }
        // raw as f32 * self.scale?
    }

    fn set_scale(&mut self, scale: Self::Scale) {
        self.scale = scale;
    }

    fn tare(&mut self, num_samples: usize) {
        // self.deactivate_interrupt();
        let mut current;
        let mut average: f32 = 0.0;
        for n in 1..=num_samples {
            while !self.is_ready() {
                self.delay.delay_us(5000u32);
                // self.delay.delay_ms(5u32);
            }
            current = self.read() as f32;
            // println!("Current = {current} average = {average}");
            self.delay.delay_us(10u32 * 1000);
            average += (current - average) / (n as f32);
        }

        self.offset = average as i32;

        // self.activate_interrupt();
    }
}
